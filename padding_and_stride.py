# -*- coding: utf-8 -*-
"""Padding and Stride.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VoZCWUSCy2rYnG-Tpa1oy-bmjFmOuumT
"""

#Padding

from mxnet import np,npx
from mxnet.gluon import nn

npx.set_np()

#For convenience, we define a function to calculate the convolutional layer.
# This function initializes the convolutional layer weights and performs
# corresponding dimensionality elevations and reductions on the input and

def comp_conv2d(conv2d, X):
  conv2d.initialize()
  X = X.reshape((1, 1) + X.shape)  ## Here (1, 1) indicates that the batch size and the number of channels are both 1
  Y = conv2d(X)
  return Y.reshape(Y.shape[2:]) #Exclude the first two dimensions that do not interest

#here 1 row or column is padded on either side, so a total of 2 rows or columns are added
conv2d = nn.Conv2D(1, kernel_size=3, padding=1)
X = np.random.uniform(size=(8, 8))
comp_conv2d(conv2d, X).shape

#Here, we use a convolution kernel with a height of 5 and a width of 3
#The padding numbers on either side of the height and width are 2 and 1 respectively
conv2d = nn.Conv2D(1, kernel_size=(5, 3), padding=(2, 1))
comp_conv2d(conv2d, X).shape

### Stride

#we set the strides on both the height and width to 2, thus halving the input height and width
conv2d = nn.Conv2D(1, kernel_size=3, padding=1, strides=2)
comp_conv2d(conv2d, X).shape

